/*
 * Connect the SD card to the following pins:
 *
 * SD Card | ESP32
 *    D2       -
 *    D3       SS
 *    CMD      MOSI
 *    VSS      GND
 *    VDD      3.3V
 *    CLK      SCK
 *    VSS      GND
 *    D0       MISO
 *    D1       -
 */
#include "FS.h"
#include "SD.h"
#include "SPI.h"


#include "WiFi.h"
#include "WiFiClient.h"

#include "ESPmDNS.h"
#include "WiFiUdp.h"
#include "ArduinoOTA.h"

#include "EEPROM.h"
#include "SPIFFS.h"
#include "AsyncTCP.h"
#include "ESPAsyncWebServer.h"


//#include "ESP_WiFiManager.h"
//#include "ESPAsyncWebServer.h"

// I2C display 
#include "esp_log.h"
#include "fonts.h"
#include "ssd1306.hpp"
#include "driver/gpio.h"
#include "driver/adc.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

using namespace std;


#define led_on_chip         2
#define BOOT_BUT            0

#define ssidAdd             0
#define passAdd             25
#define hostAdd             50
#define ssidAPAdd           75
#define passAPAdd           100


#define EEPROM_SIZE         512

/* This is random shit that needs to be sorted out */
int bufpos = 0;
char input;
char buffer[75];
String mEVLT = "", mEVHT = "", mETLT = "", mETHT = "", mEAV = "", mEAT = "", mG = "", test = "";
//float mEVLT = 0, mEVHT = 0, mETLT = 0, mETHT = 0, mEAV = 0, mEAT = 0, mG = 0;
int lastTime = 0, interval = 60000;


/* Variables used by interrupts */

#define DEBOUNCE_TIME   250
volatile uint8_t DebounceTimer = 0;
#define PIN_BUTTON      26
volatile uint8_t button_count = 0;

volatile int timer_count;
hw_timer_t * timer = NULL;


uint16_t graph[128];
int drawTime = 0, drawInterval = 10000;




/* I2C display and communication with it is handled in the code below. */


//static const char *TAG = "example";

OLED oled = OLED(GPIO_NUM_19, GPIO_NUM_21, SSD1306_128x64);

static const uint8_t qr_image[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x1b, 0xf6, 0x0f, 0xd8, 0x00, 0x7f, 
	0xfe, 0x00, 0x19, 0xf6, 0x0f, 0x98, 0x00, 0x7f, 0xfe, 0x7f, 0xde, 0x08, 0x6c, 0x19, 0xfe, 0x7f, 
	0xfe, 0x7f, 0xdc, 0x18, 0x4c, 0x19, 0xfe, 0x7f, 0xfe, 0x60, 0xd8, 0x38, 0x0f, 0x99, 0x06, 0x7f, 
	0xfe, 0x60, 0xd8, 0x38, 0x1f, 0x99, 0x06, 0x7f, 0xfe, 0x60, 0xd8, 0x38, 0x1f, 0x99, 0x06, 0x7f, 
	0xfe, 0x60, 0xd9, 0xfe, 0x60, 0x79, 0x06, 0x7f, 0xfe, 0x60, 0xdb, 0xfe, 0x60, 0x79, 0x06, 0x7f, 
	0xfe, 0x7f, 0xdf, 0x07, 0xf0, 0x99, 0xfe, 0x7f, 0xfe, 0x00, 0x1b, 0x07, 0xe0, 0x98, 0x00, 0x7f, 
	0xfe, 0x00, 0x19, 0x36, 0x6c, 0x98, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x3f, 0x90, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x3f, 0x90, 0xff, 0xff, 0xff, 0xfe, 0x03, 0x99, 0x36, 0x7c, 0x07, 0x06, 0x7f, 
	0xfe, 0x03, 0xdb, 0x36, 0x7c, 0x07, 0x86, 0xff, 0xfe, 0x73, 0xe7, 0x3e, 0x7c, 0x99, 0xcf, 0xff, 
	0xfe, 0x3c, 0x1e, 0x0c, 0x6c, 0x87, 0x36, 0x7f, 0xfe, 0x1c, 0x1e, 0x08, 0x6c, 0x87, 0x36, 0x7f, 
	0xff, 0xef, 0xe6, 0x06, 0x0f, 0x83, 0xfe, 0x7f, 0xff, 0xc7, 0xe6, 0x06, 0x0f, 0x81, 0xfe, 0x7f, 
	0xfe, 0x03, 0x06, 0x3f, 0x9f, 0x86, 0x37, 0xff, 0xff, 0x9f, 0xe0, 0x7f, 0x19, 0xe0, 0x40, 0xff, 
	0xff, 0x9f, 0xe0, 0xfe, 0x10, 0xe0, 0xc0, 0x7f, 0xfe, 0x0c, 0xc0, 0xf7, 0xf0, 0xf9, 0xc8, 0x7f, 
	0xfe, 0x0c, 0x80, 0xf7, 0xf0, 0xf9, 0xc8, 0x7f, 0xfe, 0x13, 0x61, 0xc8, 0x7f, 0x18, 0x37, 0xff, 
	0xfe, 0x1a, 0x21, 0xcc, 0x7f, 0x18, 0x23, 0xff, 0xfe, 0x1c, 0x1e, 0xce, 0x6f, 0xf8, 0xc1, 0xff, 
	0xff, 0xfc, 0x21, 0x30, 0x6f, 0x1f, 0xce, 0x7f, 0xff, 0xfc, 0x61, 0x30, 0x6f, 0x1f, 0xce, 0x7f, 
	0xfe, 0x7c, 0x9f, 0xc1, 0x8f, 0x7e, 0x01, 0xff, 0xfe, 0x7c, 0xdf, 0xc1, 0x8f, 0x7e, 0x01, 0xff, 
	0xff, 0xe0, 0xff, 0x31, 0x93, 0x67, 0xf8, 0x7f, 0xff, 0x83, 0xd8, 0x33, 0xef, 0x00, 0x06, 0x7f, 
	0xff, 0x83, 0x98, 0x37, 0xef, 0x00, 0x06, 0x7f, 0xff, 0xff, 0xf8, 0x36, 0x7f, 0x1f, 0x09, 0xff, 
	0xff, 0xff, 0xf8, 0x36, 0x7f, 0x1f, 0x09, 0xff, 0xfe, 0x00, 0x1e, 0xcf, 0x80, 0x99, 0x01, 0xff, 
	0xfe, 0x00, 0x1e, 0x4f, 0x80, 0x9b, 0x01, 0xff, 0xfe, 0x7f, 0xdf, 0x07, 0x8c, 0x1f, 0x3f, 0xff, 
	0xfe, 0x60, 0xde, 0xf7, 0x9c, 0x00, 0x38, 0x7f, 0xfe, 0x60, 0xde, 0xf7, 0x9c, 0x00, 0x38, 0x7f, 
	0xfe, 0x60, 0xd8, 0xf6, 0x73, 0xff, 0x31, 0xff, 0xfe, 0x60, 0xd8, 0x76, 0x73, 0xff, 0x31, 0xff, 
	0xfe, 0x60, 0xd8, 0x3f, 0xf3, 0xe6, 0xf6, 0x7f, 0xfe, 0x7f, 0xd8, 0x1c, 0x03, 0xfe, 0x36, 0x7f, 
	0xfe, 0x7f, 0xd8, 0x08, 0x03, 0xfe, 0x36, 0x7f, 0xfe, 0x00, 0x19, 0x08, 0x6f, 0x79, 0xf9, 0xff, 
	0xfe, 0x00, 0x1b, 0x0c, 0x6f, 0x7b, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

static const uint8_t pib_logo[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xfc, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0xff, 0xc0, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xf1, 0xff, 0xc0, 0xff, 0xe7, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xf9, 0xff, 0xc0, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xfc, 0xff, 0xc0, 0xff, 
	0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0xef, 0xfc, 0xff, 0xc0, 
	0xff, 0xcf, 0xc7, 0xff, 0xff, 0xff, 0xc7, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0x9f, 0xff, 0xff, 
	0xff, 0xf3, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0xbf, 0xff, 0xff, 0xff, 0xfb, 0xef, 0xfc, 0xff, 
	0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xff, 0xff, 0xf9, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 
	0xff, 0xff, 0xf9, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xff, 0xff, 0xf9, 0xef, 0x1c, 
	0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xff, 0xff, 0xf9, 0xee, 0x5c, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 
	0xff, 0xff, 0xff, 0xf9, 0xed, 0x4c, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xff, 0xff, 0xf9, 0xed, 
	0x5c, 0xff, 0xc0, 0xff, 0xcf, 0x3e, 0x3f, 0xff, 0xfc, 0x39, 0xed, 0x4c, 0xff, 0xc0, 0xff, 0xcf, 
	0x3d, 0xdf, 0xff, 0xfb, 0x99, 0xed, 0x4c, 0xff, 0xc0, 0xff, 0xcf, 0x3b, 0xcf, 0xff, 0xff, 0x99, 
	0xee, 0x5c, 0xff, 0xc0, 0xff, 0xcf, 0x3b, 0x8f, 0xff, 0xfb, 0x99, 0xef, 0x3c, 0xff, 0xc0, 0xff, 
	0xcf, 0x39, 0x0f, 0xff, 0xf8, 0x19, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0x3c, 0x1f, 0x7e, 0xf8, 
	0x39, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0x3e, 0x3f, 0x7e, 0xfc, 0x79, 0xef, 0x3c, 0xff, 0xc0, 
	0xff, 0xcf, 0x3f, 0xff, 0xbd, 0xff, 0xf9, 0xee, 0x5c, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xbd, 
	0xff, 0xf9, 0xec, 0x4c, 0xff, 0xc0, 0xff, 0xcf, 0x3b, 0xff, 0xc9, 0xff, 0xf9, 0xed, 0x4c, 0xff, 
	0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xe7, 0xff, 0xf9, 0xed, 0x5c, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 
	0xff, 0xff, 0xf9, 0xed, 0x4c, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xff, 0xff, 0xf9, 0xee, 0x4c, 
	0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xff, 0xff, 0xf9, 0xef, 0x1c, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 
	0xff, 0xff, 0xff, 0xf9, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xff, 0xff, 0xf9, 0xef, 
	0xfc, 0xff, 0xc0, 0xff, 0xcf, 0x3f, 0xff, 0xff, 0xff, 0xf9, 0xef, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 
	0xbf, 0xff, 0xff, 0xff, 0xf9, 0xec, 0x1c, 0xff, 0xc0, 0xff, 0xcf, 0xbf, 0xff, 0xff, 0xff, 0xfb, 
	0xe9, 0xec, 0xff, 0xc0, 0xff, 0xcf, 0x9f, 0xff, 0xff, 0xff, 0xf3, 0xeb, 0xfc, 0xff, 0xc0, 0xff, 
	0xcf, 0xc0, 0x00, 0x00, 0x00, 0x07, 0xeb, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0xf8, 0x00, 0x00, 0x00, 
	0x3f, 0xeb, 0xfc, 0xff, 0xc0, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xeb, 0xec, 0xff, 0xc0, 
	0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xec, 0x0c, 0xff, 0xc0, 0xff, 0xef, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xef, 0xfd, 0xff, 0xc0, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xf9, 0xff, 
	0xc0, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xe3, 0xff, 0xc0, 0xff, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xc0, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xff, 0xc0, 0xff, 0xff, 0x3e, 0x7f, 0xff, 0xff, 0xff, 0xcf, 0x9f, 0xff, 0xc0, 0xff, 0xff, 0x00, 
	0x7f, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xc0, 0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xe0, 
	0x3f, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0
};

static const uint8_t ss_logo[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x70, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x0e, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x80, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x01, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0xf8, 0x1f, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xf8, 0x1f, 0x1c, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xf8, 0x1f, 0x0e, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xe1, 0xf0, 0x1f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0xc1, 0xf0, 0x1f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x81, 0xf0, 0x1f, 0x03, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x81, 0xf0, 0x3e, 0x01, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0x01, 0xf0, 0x3e, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 
	0x01, 0xf0, 0x3e, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x03, 0xfc, 0x3f, 0xc0, 
	0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x03, 0xfc, 0x3f, 0xc0, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1c, 0x03, 0xfc, 0x3f, 0x80, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 
	0x03, 0xfc, 0x7f, 0x80, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xfc, 0x0f, 0x80, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0xf8, 0x0f, 0x80, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x80, 0xf8, 0x0f, 0x81, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0xc0, 0xf8, 0x0f, 0x83, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf8, 0x1f, 0x07, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf8, 0x1f, 0x0e, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0xf8, 0x1f, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x39, 0xf0, 0x1f, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xf0, 0x1f, 0x38, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x70, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1c, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0e, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t jan[] = {
    0xff, 0xff, 0xf3, 0x5c, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe8, 0xa4, 0xdf, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xc4, 0x01, 0x08, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x94, 0x00, 0x00, 0x35, 0xff, 0xff, 
	0xff, 0xff, 0x80, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 
	0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x20, 0x00, 0x00, 0x3f, 0xff, 
	0xff, 0xfc, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x01, 0x3f, 0xff, 
	0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xa0, 0xf3, 0xe0, 0x00, 0x00, 0x4f, 0xff, 
	0xff, 0x81, 0xff, 0xff, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x83, 0xff, 0xff, 0x80, 0xc0, 0x01, 0xff, 
	0xff, 0x07, 0xff, 0xff, 0xe1, 0xc0, 0x02, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xf0, 0x00, 0xff, 
	0xff, 0x87, 0xff, 0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xfe, 0x01, 0xff, 
	0xff, 0x8f, 0xff, 0xff, 0xff, 0xfe, 0x01, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 
	0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 
	0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x7f, 
	0xff, 0x0f, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x7f, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x7f, 
	0xff, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xff, 0x0f, 0x87, 0xff, 0xff, 0xfc, 0x00, 0x7f, 
	0xff, 0x00, 0x01, 0xff, 0x03, 0xfc, 0x00, 0x7f, 0xff, 0x81, 0xc0, 0x1c, 0x00, 0x7e, 0x00, 0x7f, 
	0xff, 0x87, 0x00, 0x00, 0x07, 0x00, 0x01, 0xff, 0xff, 0x9f, 0x00, 0x78, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0xe1, 0x79, 0x00, 0x3c, 0x19, 0xff, 0xff, 0xff, 0xf3, 0x79, 0x8f, 0xbc, 0x39, 0xff, 
	0xff, 0xff, 0xfe, 0xfd, 0xdf, 0xbe, 0x3d, 0xff, 0xff, 0xff, 0xfd, 0xfe, 0xff, 0xfe, 0xfd, 0xff, 
	0xff, 0xdf, 0xfb, 0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xdf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x8f, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xdf, 0xff, 0x9f, 0xff, 0xef, 0xff, 
	0xff, 0xff, 0x9f, 0xef, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xc1, 0xe3, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xc7, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 
	0xff, 0xfe, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfb, 0x01, 0xfc, 0xfe, 0xff, 0xff, 
	0xff, 0xff, 0xc7, 0xfc, 0x0c, 0xfc, 0x3f, 0xff, 0xff, 0xff, 0xf7, 0xff, 0x81, 0xfc, 0x7f, 0xff, 
	0xff, 0xff, 0xfc, 0x00, 0x9d, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xfc, 0x00, 0x43, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x0f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xfc, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x3f, 0xff, 0xff, 0xff
};

void drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h, ssd1306_color_t color)
{
    // The color BLACK given means the colors are inverted!
    int16_t byteWidth = (w + 7) / 8;
    uint8_t byte = 0;
    if (color == WHITE)
        oled.fill_rectangle(x, y, w, h, BLACK);
    else
        oled.fill_rectangle(x, y, w, h, WHITE);
    for (int16_t j = 0; j < h; j++, y++)
    {
        for (int16_t i = 0; i < w; i++)
        {
            if (i & 7)
                byte <<= 1;
            else 
                byte = pgm_read_byte(&bitmap[j * byteWidth + i / 8]);
            if (byte & 0x80)
                oled.draw_pixel(x + i, y, color);
        }
    }
    oled.refresh(true);
}

void draw_qr()
{


    /*
    int y = 0;
    oled.fill_rectangle(0, 0, 128, 64, WHITE);
    // Make the four squares
    oled.draw_rectangle(0, 0, 7, 7, BLACK);
    oled.draw_rectangle(22, 0, 7, 7, BLACK);
    oled.draw_rectangle(0, 22, 7, 7, BLACK);
    oled.fill_rectangle(2, 2, 3, 3, BLACK);
    oled.fill_rectangle(24, 2, 3, 3, BLACK);
    oled.fill_rectangle(2, 24, 3, 3, BLACK);

    // Line 0
    y = 0;
    oled.draw_pixel(8, y, BLACK);
    oled.draw_pixel(12, y, BLACK);
    for(int i = 14; i < 17; i++)
    {
        oled.draw_pixel(i, y, BLACK);
    }
    oled.draw_pixel(20, y, BLACK);

    
    // Line 1
    y = 1;
    for(int i = 9; i < 12; i++)
        oled.draw_pixel(i, y, BLACK);
    oled.draw_pixel(13, y, BLACK);
    oled.draw_pixel(14, y, BLACK);
    oled.draw_pixel(16, y, BLACK);
    for(int i = 18; i < 21; i++)
        oled.draw_pixel(i, y, BLACK);
    
    // Line 2
    y = 2;
    oled.draw_hline(8, y, 3, BLACK);
    oled.draw_hline(13, y, 4, BLACK);
    oled.draw_pixel(20, y, BLACK);

    // Line 3
    y = 3;
    oled.draw_hline(8, y, 4, BLACK);
    oled.draw_hline(13, y, 3, BLACK);
    oled.draw_pixel(20, y, BLACK);

    // Line 4
    y = 4;
    oled.draw_pixel(8, y, BLACK);
    oled.draw_pixel(14, y, BLACK);
    oled.draw_hline(16, y, 4, BLACK);

    // Line 5
    y = 5;
    oled.draw_hline(10, y, 3, BLACK);
    oled.draw_hline(17, y, 2, BLACK);
    oled.draw_pixel(20, y, BLACK);

    // Line 6
    y = 6;
    for(int i = 8; i < 21; i += 2)
        oled.draw_pixel(i, y, BLACK);

    // Line 7
    y = 7;
    oled.draw_pixel(10, y, BLACK);
    oled.draw_pixel(15, y, BLACK);
    oled.draw_hline(17, y, 2, BLACK);

    // Line 8
    y = 8;
    oled.draw_hline(0, y, 4, BLACK);
    oled.draw_pixel(6, y, BLACK);
    oled.draw_pixel(8, y, BLACK);
    oled.draw_pixel(10, y, BLACK);
    oled.draw_pixel(12, y, BLACK);
    oled.draw_pixel(14, y, BLACK);
    oled.draw_hline(18, y, 4, BLACK);
    oled.draw_hline(24, y, 3, BLACK);
    oled.draw_pixel(28, y, BLACK);
    
    */


    oled.refresh(true);
}

void graph_data(const char * use, const char * back)
{
    ostringstream os;

    os << "Usage: " << atoi(use);
    oled.clear();
    oled.draw_string(0, 0, os.str(), WHITE, BLACK);
    for (uint8_t i = 0; i < 128; i++) {
        oled.draw_pixel(i, 63 - graph[i], WHITE);
    }
    oled.draw_pixel(127, 63 - graph[127], WHITE);

    oled.refresh(true);
}

void table_data(const char * use, const char * back, const char * uLowT, const char * uHighT, const char * bLowT, const char * bHighT, const char* gas)
{
    oled.clear();
    int fontHeight = oled.get_font_height();
    int xDataOff = 50;

    oled.draw_string(0, 0, "Use", WHITE, BLACK);
    oled.draw_string(0, 9, "Back", WHITE, BLACK);
    oled.draw_string(0, 18, "Used L", WHITE, BLACK);
    oled.draw_string(0, 27, "Used H", WHITE, BLACK);
    oled.draw_string(0, 36, "Back L", WHITE, BLACK);
    oled.draw_string(0, 45, "Back H", WHITE, BLACK);
    oled.draw_string(0, 54, "Gas", WHITE, BLACK);

    oled.draw_string(xDataOff, 0, use, WHITE, BLACK);
    oled.draw_string(xDataOff, 9, back, WHITE, BLACK);
    oled.draw_string(xDataOff, 18, uLowT, WHITE, BLACK);
    oled.draw_string(xDataOff, 27, uHighT, WHITE, BLACK);
    oled.draw_string(xDataOff, 36, bLowT, WHITE, BLACK);
    oled.draw_string(xDataOff, 45, bHighT, WHITE, BLACK);
    oled.draw_string(xDataOff, 54, gas, WHITE, BLACK);

    oled.refresh(true);
}

void showData(const char * useNow, const char * backNow = "", const char * useLowTot = "", const char * useHighTot = "", const char * backLowTot = "", const char * backHighTot = "", const char * gas = "", int font = 0)
{
    switch(button_count)
    {
        case 0:
        {
            table_data(useNow, backNow, useLowTot, useHighTot, backLowTot, backHighTot, gas);
            break;
        }
        case 1:
        {
            graph_data(useNow, backNow);
            break;
        }
        case 2:
        {
            if (timer_count >= 5)
                table_data(useNow, backNow, useLowTot, useHighTot, backLowTot, backHighTot, gas);
            else
                graph_data(useNow, backNow);
            break;
        }
        default:
        {
            break;
        }
    }
    
    if (millis() - drawTime > drawInterval)
    {
        drawTime = millis();

        for (int i = 0; i < 127; i++)
        {
            graph[i] = graph[i + 1];
        }
        graph[127] = atoi(useNow);
        graph[127] = graph[127] * 48 / 9600;
    }
}


/* This code is meant for writing to an SD Card with the use of SPI. */

void listDir(fs::FS &fs, const char * dirname, uint8_t levels){
    Serial.printf("Listing directory: %s\n", dirname);

    File root = fs.open(dirname);
    if(!root){
        Serial.println("Failed to open directory");
        return;
    }
    if(!root.isDirectory()){
        Serial.println("Not a directory");
        return;
    }

    File file = root.openNextFile();
    while(file){
        if(file.isDirectory()){
            Serial.print("  DIR : ");
            Serial.println(file.name());
            if(levels){
                listDir(fs, file.name(), levels -1);
            }
        } else {
            Serial.print("  FILE: ");
            Serial.print(file.name());
            Serial.print("  SIZE: ");
            Serial.println(file.size());
        }
        file = root.openNextFile();
    }
}

void createDir(fs::FS &fs, const char * path){
    Serial.printf("Creating Dir: %s\n", path);
    if(fs.mkdir(path)){
        Serial.println("Dir created");
    } else {
        Serial.println("mkdir failed");
    }
}

void removeDir(fs::FS &fs, const char * path){
    Serial.printf("Removing Dir: %s\n", path);
    if(fs.rmdir(path)){
        Serial.println("Dir removed");
    } else {
        Serial.println("rmdir failed");
    }
}

void readFile(fs::FS &fs, const char * path){
    Serial.printf("Reading file: %s\n", path);

    File file = fs.open(path);
    if(!file){
        Serial.println("Failed to open file for reading");
        return;
    }

    Serial.print("Read from file: ");
    while(file.available()){
        Serial.write(file.read());
    }
    file.close();
}

void writeFile(fs::FS &fs, const char * path, const char * message){
    Serial.printf("Writing file: %s\n", path);

    File file = fs.open(path, FILE_WRITE);
    if(!file){
        Serial.println("Failed to open file for writing");
        return;
    }
    if(file.print(message)){
        Serial.println("File written");
    } else {
        Serial.println("Write failed");
    }
    file.close();
}

void appendFile(fs::FS &fs, const char * path, const char * message){
    Serial.printf("Appending to file: %s\n", path);

    File file = fs.open(path, FILE_APPEND);
    if(!file){
        Serial.println("Failed to open file for appending");
        return;
    }
    if(file.print(message)){
        Serial.println("Message appended");
    } else {
        Serial.println("Append failed");
    }
    file.close();
}

void renameFile(fs::FS &fs, const char * path1, const char * path2){
    Serial.printf("Renaming file %s to %s\n", path1, path2);
    if (fs.rename(path1, path2)) {
        Serial.println("File renamed");
    } else {
        Serial.println("Rename failed");
    }
}

void deleteFile(fs::FS &fs, const char * path){
    Serial.printf("Deleting file: %s\n", path);
    if(fs.remove(path)){
        Serial.println("File deleted");
    } else {
        Serial.println("Delete failed");
    }
}

void testFileIO(fs::FS &fs, const char * path){

    File file = fs.open(path);
    static uint8_t buf[512];
    size_t len = 0;
    uint32_t start = millis();
    uint32_t end = start;
    if(file){
        len = file.size();
        size_t flen = len;
        start = millis();
        while(len){
            size_t toRead = len;
            if(toRead > 512){
                toRead = 512;
            }
            file.read(buf, toRead);
            len -= toRead;
        }
        end = millis() - start;
        Serial.printf("%u bytes read for %u ms\n", flen, end);
        file.close();
    } else {
        Serial.println("Failed to open file for reading");
    }


    file = fs.open(path, FILE_WRITE);
    if(!file){
        Serial.println("Failed to open file for writing");
        return;
    }

    size_t i;
    start = millis();
    for(i=0; i<2048; i++){
        file.write(buf, 512);
    }
    end = millis() - start;
    Serial.printf("%u bytes written for %u ms\n", 2048 * 512, end);
    file.close();
}

void createMeterLog(fs::FS &fs, const char * path)
{
    // const char message = "Tijd, Laag verbruik, Hoog verbruik, Laag geleverd, Hoog geleverd, Actueel verbruik, Actueel geleverd, Totaal gas";
    Serial.printf("Creating Meter log file: %s\n", path);

    File file = fs.open(path, FILE_WRITE);
    if(!file)
    {
        Serial.printf("Failed to open file for writing\n");
        return;
    }
    if(file.print("Tijd,Laag verbruik,Hoog verbruik,Laag geleverd,Hoog geleverd,Actueel verbruik,Actueel geleverd,Totaal gas\n"))
        Serial.printf("Meter log created\n");
    else
        Serial.printf("Creating Meter log failed\n");
    file.close();
    



}

void logData(fs::FS &fs, const char * path)
{
    Serial.printf("Logging data\n");

    File file = fs.open(path, FILE_APPEND);
    if(!file)
    {
        Serial.printf("Failed to open file for writing\n");
        return;
    }
    if(file.printf(" ,%s,%s,%s,%s,%s,%s,%s\n", &mEVLT, &mEVHT, &mETLT, &mETHT, &mEAV, &mEAT, &mG))
        Serial.printf("Log updated");
    else
        Serial.printf("Update failed");
    file.close();
}

/* The code below is for storing data on the microcontroller in the EEPROM and the SPIFFS. */

void write_eeprom(int address, const String &value)
{
    int length = value.length();
    EEPROM.write(address, length);

    for (int i = 0; i < length; i++)
    {
        EEPROM.write(address + 1 + i, value[i]);
    }
    if (EEPROM.commit())
        Serial.printf("Data stored\n");

}

String read_eeprom(int address)
{
    int length = EEPROM.read(address);
    //Serial.println(length);
    String dataStr;
    //char data[length];
    //char *ptr;

    for (int i = 0; i < length; i++)
    {
        dataStr += char(EEPROM.read(address + 1 + i));
        //data[i] = EEPROM.read(address + 1 + i);
    }
    //Serial.printf("Data from EEPROM: %s\n", data);
    // for (int i = 0; i < length; i++)
    // {
    //     outStr[i] = data[i];
    // }
    //Serial.printf("data from EEPROM string: %s\n", dataStr.c_str());
    //Serial.printf("data from EEPROM: %s\n", data);
    return dataStr;
}

/* The code below is for the WiFi connection and making a webserver. */


//WiFiServer server(80);
AsyncWebServer server(80);
AsyncWebSocket ws("/ws");

String header;
unsigned long currentTime = millis();
unsigned long previousTime = 0;
const long timeoutTime = 2000;
 
void decodeTelegram()
{

    long tl = 0, tld = 0;
    float temp = 0;

    if (Serial.available())
    {
        input = Serial.read();
        char inChar = (char)input;
        /* Fill buffer up to and includeing a new line (\n) */
        buffer[bufpos] = input&127;
        bufpos++;

        if (input == '\n') 
        {   // We received a new line (data up to \n)

            // 1-0:1.8.1 = low tarif consumption
            if (sscanf(buffer, "1-0:1.8.1(%f", &temp) == 1)
            {
                mEVLT = temp; 
            }

            // 1-0:1.8.2 = high tarif consumption
            if (sscanf(buffer,"1-0:1.8.2(%f", &temp) == 1)
            {
                mEVHT = temp;
            }

            // 1-0:2.8.1 = low tarif generated
            if (sscanf(buffer,"1-0:2.8.1(%f", &temp) == 1)
            {
                mETLT = temp;
            }

            // 1-0:2.8.1 = high tarif generated
            if (sscanf(buffer,"1-0:2.8.2(%f", &temp) == 1)
            {
                mETHT = temp;
            }

            // 1-0:1.7.0 = actual consumption
            if (sscanf(buffer,"1-0:1.7.0(%f", &temp) == 1)
            {
                temp *= 100;
                mEAV = (int)temp;
            }

            // 1-0:2.7.0 = actual generated
            if (sscanf(buffer,"1-0:2.7.0(%f", &temp) == 1)
            {
                temp *= 100;
                mEAT = (int)temp;
            }

            // 0-1:24.2.1 = gas
            // if (sscanf(buffer,"0-1:24.3.0(%*s)(%*s)(%f", &temp) == 1)
            // {
            //     mG = temp;
            //     Serial.printf("gas data read: %s\n", mG);
            // }
            // 0-1:24.2.1 = gas
            if (strncmp(buffer,"0-1:24.2.1", strlen("0-1:24.2.1")) == 0)
            {
                if (sscanf(strrchr(buffer, '(') + 1, "%ld.%ld", &tl, &tld) == 2)
                {
                    mG = String(((tl*1000) + tld));
                }
            }
            // Other data can be placed down here if needed

            for (int i=0; i<75; i++)
            {
                buffer[i] = 0;
            }
              bufpos = 0;
      

        }

    }
}


void notifyClients()
{
    
}


void handleWebSocketMessage(void *arg, uint8_t *data, size_t len)
{
    AwsFrameInfo *info = (AwsFrameInfo*)arg;
    if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT)
    {
        data[len] = 0;
        if (strcmp((char*)data, "toggle") == 0) 
        {
            //led
        }
    }
}

void onEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len)
{
    switch (type)
    {
        case WS_EVT_CONNECT:
            Serial.printf("WebSocket client #%u connected from %s\n", client->id(), client->remoteIP().toString().c_str());
            break;
        case WS_EVT_DISCONNECT:
            Serial.printf("WebSocket client #%u disconnected\n", client->id());
            break;
        case WS_EVT_DATA:
            handleWebSocketMessage(arg, data, len);
            break;
            case WS_EVT_PONG:
            case WS_EVT_ERROR:
            default:
                break;
    }
}

void initWebSocket()
{
    //ws.onEvent(onEvent);
    //server.addHandler(&ws);
}

void scanWifi()
{
    int n = WiFi.scanNetworks();
    Serial.println("Network scan done!");

    if(n == 0)
        Serial.println("No networks found");
    else
    {
        Serial.printf("%i networks found\n", n);
        for(int i = 0; i < n; ++i)
        {
            // Print SSID and RSSI for all the found networks
            Serial.print(i + 1);
            Serial.print(": ");
            Serial.print(WiFi.SSID(i));
            Serial.print(" (");
            Serial.print(WiFi.RSSI(i));
            Serial.print(")");
            Serial.println((WiFi.encryptionType(i) == WIFI_AUTH_OPEN)?" ":"*");
            delay(10);
        }
    }
    

}

void show_spiffs()
{
    File file = SPIFFS.open("/logs/log.txt", "r");
    String test;

    if (!file)
    {
        // File not found
        Serial.printf("Failed to open file\n");
        return;
    }
    else
    {
        test = file.readString();
        Serial.printf("String read from file: %s\n", test.c_str());
        file.close();
    }
    
}

TaskHandle_t Task1;
TaskHandle_t Task2;

/*
void Task1code( void * pvParameters )
{
    Serial.printf("Task1 running on core ");
    Serial.println(xPortGetCoreID());
    //Serial.printf("\n");

    for(;;)
    {
        clientWebpage();
        delay(1);
    }


}
*/


/* All the interrupts are below */

void IRAM_ATTR buttonpressed()
{
    if (millis() - DEBOUNCE_TIME >= DebounceTimer )
    {
        DebounceTimer = millis();
        button_count++;
        if (button_count == 3)
            button_count = 0;
    }
}


void IRAM_ATTR timer_handle()
{
    timer_count++;
    if (timer_count >= 6)
        timer_count = 0;

}


/* Hardware is constructed */
struct Button {
    const uint8_t PIN;
    uint32_t keyPresses;
    bool pressed;
};


/* Tasks for use of multi core */

void webpage_task(void * pvParameters)
{

    for (;;)
    {

    }
}

void write_sd(void * pvParameters)
{

}


/* Initilizing functions */

void oled_init()
{
    if (!oled.init())
    {
        Serial.printf("An error has occurred while initilizing oled display\n");
        return;
    }
    oled.select_font(0);    // Select font_glcd_5x7

    //drawBitmap(0,0, qr_image, 64, 64, WHITE);



}

void timer_init()
{
    timer = timerBegin(0, 80, true);
    
    
    timerAttachInterrupt(timer, &timer_handle, true);
    // Sets an alarm to go off every 10 seconds or 10.000.000 ticks
    timerAlarmWrite(timer, 10000000, true);

    timerAlarmEnable(timer);

}

void board_init()
{
    pinMode(PIN_BUTTON, INPUT_PULLDOWN);
    pinMode(BOOT_BUT, INPUT_PULLDOWN);

    attachInterrupt(PIN_BUTTON, buttonpressed, RISING);    
}

void memory_init()
{
    if(!SPIFFS.begin(true))
    {
        Serial.printf("An error has occurred while mounting SPIFFS\n");
        return;
    }

    if(!EEPROM.begin(EEPROM_SIZE))
    {
        Serial.printf("An error has occured while mounting EEPROM\n");
        return;
    }
    Serial.printf("Total bytes SPIFFS: %i\n", SPIFFS.totalBytes());
    Serial.printf("Used bytes SPIFFS: %i\n", SPIFFS.usedBytes());
}

void wifi_init()
{
    digitalWrite(led_on_chip, HIGH);

    // Variables needed for getting data of the EEPROM with all the necessary data 
    // ssidAdd = 0, passAdd = 25, hostAdd = 50, ssidAPAdd = 75, passAPAdd = 100; 
    String ssid, pass, host, ssidAP, passAP;


    ssid = read_eeprom(ssidAdd);
    pass = read_eeprom(passAdd);
    host = read_eeprom(hostAdd);
    //ssidAP = read_eeprom(ssidAPAdd);
    //passAP = read_eeprom(passAPAdd);

    WiFi.setHostname(host.c_str());
    WiFi.begin(ssid.c_str(), pass.c_str());
    delay(1000);
    if (WiFi.status() != WL_CONNECTED)
    {
        Serial.printf("Failed connect wifi, starting AP\n");
        WiFi.softAP("Meterdisplay_AP","Slimmemeter");
        //WiFi.softAP(ssidAP.c_str(), passAP.c_str());
        IPAddress IP = WiFi.softAPIP();
        Serial.printf("AP name: %s\n AP IP: %x\n", ssidAP.c_str(), IP);
        //Serial.printf("AP IP address: %x\n", IP);
        Serial.println(IP);
        drawBitmap(0,0, qr_image, 64, 64, BLACK);
    }
    else
    {
        Serial.printf("Wifi connected to %s\n", ssid.c_str());
        Serial.printf("IP Address: ");
        Serial.println(WiFi.localIP());
    }

    digitalWrite(led_on_chip, LOW);
}

void webserver_init()
{
    server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
        request->send(SPIFFS, "/index.html", String());
    });

    server.on("/index.html", HTTP_GET, [](AsyncWebServerRequest *request){
        request->send(SPIFFS, "/index.html", String());
    });

    server.on("/style.css", HTTP_GET, [](AsyncWebServerRequest *request){
        request->send(SPIFFS, "/style.css", "text/css");
    });

    server.on("/settings.html", HTTP_GET, [](AsyncWebServerRequest *request){
        request->send(SPIFFS, "/settings.html", String());
    });
    
    server.on("/get", HTTP_GET, [] (AsyncWebServerRequest *request){
        String temp;
        if (request->getParam("SSID")->value() != emptyString && request->getParam("PASS")->value() != emptyString)
        {
            write_eeprom(ssidAdd, request->getParam("SSID")->value());
            write_eeprom(passAdd, request->getParam("PASS")->value());
        }
        if (request->getParam("HOST")->value() != emptyString)
            write_eeprom(hostAdd, request->getParam("HOST")->value());
        if (request->hasParam("PROTOCOL"))
            temp = request->getParam("PROTOCOL")->value();
            if (temp == "DSMR5.0");
            {
                Serial.end();
                Serial.begin(115200, SERIAL_8N1);
            }
            //temp = "DSMR2.2";
            if (temp == "DSMR2.2");
            {
                Serial.end();
                Serial.begin(9600, SERIAL_7E1);
            }
        request->send(SPIFFS, "/settings.html", String());
    });

    server.on("/log.html", HTTP_GET, [] (AsyncWebServerRequest *request){
        show_spiffs();
        request->send(SPIFFS, "/index.html", String());
    });

    server.on("/about", HTTP_GET, [](AsyncWebServerRequest *request){
        request->send(SPIFFS, "/about.html", String());
    });


    server.begin();
}

void ota_init()
{
    ArduinoOTA
    .onStart([]() {
      String type;
      if (ArduinoOTA.getCommand() == U_FLASH)
        type = "sketch";
      else // U_SPIFFS
        type = "filesystem";

      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
      Serial.println("Start updating " + type);
    })
    .onEnd([]() {
      Serial.println("\nEnd");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      Serial.printf("Error[%u]: ", error);
      if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
      else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
      else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
      else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
      else if (error == OTA_END_ERROR) Serial.println("End Failed");
    });

  ArduinoOTA.begin();

  //Serial.println("Ready");
  //Serial.print("IP address: ");
  //Serial.println(WiFi.localIP());
}

void sd_init()
{
    if (!SD.begin())
    {
        Serial.println("Card Mount Failed");
        return;
    }
}

/* MAIN CODE */

void setup(){
    Serial.begin(115200, SERIAL_8N1, 2, 14);       // Starts default serial connection which is also DSMR5.0
    
    timer_init();
    board_init();
    memory_init();
    oled_init();
    wifi_init();
    webserver_init();
    ota_init();
    sd_init();

    if(!SD.begin()){
        Serial.println("Card Mount Failed");
        return;
    }
    uint8_t cardType = SD.cardType();

    if(cardType == CARD_NONE){
        Serial.println("No SD card attached");
        return;
    }

    Serial.print("SD Card Type: ");
    if(cardType == CARD_MMC){
        Serial.println("MMC");
    } else if(cardType == CARD_SD){
        Serial.println("SDSC");
    } else if(cardType == CARD_SDHC){
        Serial.println("SDHC");
    } else {
        Serial.println("UNKNOWN");
    }

    uint64_t cardSize = SD.cardSize() / (1024 * 1024);
    Serial.printf("SD Card Size: %lluMB\n", cardSize);

    createMeterLog(SD, "/MeterLog.txt");




    
    
    

    // listDir(SD, "/", 0);
    // createDir(SD, "/mydir");
    // listDir(SD, "/", 0);
    // removeDir(SD, "/mydir");
    // listDir(SD, "/", 2);
    // writeFile(SD, "/hello.txt", "Hello ");
    // appendFile(SD, "/hello.txt", "World!\n");
    // readFile(SD, "/hello.txt");
    // deleteFile(SD, "/foo.txt");
    // renameFile(SD, "/hello.txt", "/foo.txt");
    // readFile(SD, "/foo.txt");
    // testFileIO(SD, "/test.txt");
    // createMeterLog(SD, "/MeterLog.txt");
    // Serial.printf("Total space: %lluMB\n", SD.totalBytes() / (1024 * 1024));
    // Serial.printf("Used space: %lluMB\n", SD.usedBytes() / (1024 * 1024));

}




void loop(){

    ArduinoOTA.handle();
    if(millis() - lastTime > interval)
    {
        lastTime = millis();

        Serial.printf("Alle data: %s, %s, %s, %s, %s, %s, %s\n", &mEVLT, &mEVHT, &mETLT, &mETHT, &mEAV, &mEAT, &mG);
        logData(SD, "/MeterLog.txt");

        // Reset the variables for the next run
        // mEVLT = "";
        // mEVHT = "";
        // mETLT = "";
        // mETHT = "";
        // mEAV = "";
        // mEAT = "";
        // mG = "";
    }
    decodeTelegram();
    showData(mEAV.c_str(), mEAT.c_str(), mEVLT.c_str(), mEVHT.c_str(), mETLT.c_str(), mETHT.c_str(), mG.c_str());

}